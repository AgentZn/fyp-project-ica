<!DOCTYPE html>
<html lang="en">
<head>
  <title>ICA Prototype</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.0.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="static/config.js"></script>

  <style>
    /* Remove the navbar's default margin-bottom and rounded borders */ 
    .navbar {
  margin-bottom: 0;
  border-radius: 0;
  background-color: #1a1a1a;
}

.navbar-brand {
  color: #f9f9f9;
  font-size: 1.5em;
}

.navbar-nav > li > a {
  color: #f9f9f9;
}

.navbar-nav > li > a:hover {
  color: #f1f1f1;
  background-color: #333;
}

.navbar-nav > .active > a {
  background-color: #333;
}

/* Content styling */
.container-fluid {
  padding: 2em;
}

.row.content {
  height: auto;
  margin-bottom: 2em;
}

.sidenav {
  padding-top: 20px;
  background-color: #f1f1f1;
  height: 100%;
  border-right: 1px solid #ddd;
}

.text-left {
  padding: 2em;
}

/* Footer styling */
footer {
  background-color: #1a1a1a; 
  color: white;
  padding: 15px;
  position: fixed;
  width: 100%;
  bottom: 0;
}

/* Modal styling */
#modalContainer {
  position: fixed;
  z-index: 1;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.4);
}

#durationModal {
  background-color: #fefefe;
  margin: 15% auto;
  padding: 20px;
  border: 1px solid #888;
  width: 30%;
  border-radius: 10px; 
  box-shadow: 0 2px 5px rgba(0,0,0,.3);
}

/* Button styling */
#okButton{
  background-color: #4CAF50; /* Green background */
  border: none;
  color: white;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer;
  padding: 10px 24px;
  transition-duration: 0.4s; /* Animation to change color */
  border-radius: 12px; /* Rounded corners */
}

#okButton:hover {
  background-color: #45a049; /* Darker green when mouse hovers over */
}

/* Responsive styling */
@media screen and (max-width: 767px) {
  .sidenav {
    height: auto;
    padding: 15px;
  }
  .row.content {height:auto;} 
}
  </style>

</head>

<body>

  <nav class="navbar navbar-inverse">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>                        
        </button>
        <a class="navbar-brand" href="#">Intelligent Calisthenics Assistant (ICA) </a>
      </div>
      <div class="collapse navbar-collapse" id="myNavbar">
        <ul class="nav navbar-nav">
          <li class="active"><a href="#">Home</a></li>
          <li><a href="#">About</a></li>
          <li><a href="#">Contact</a></li>
        </ul>
        <ul class="nav navbar-nav navbar-right">
          <li><a href="#"><span class="glyphicon glyphicon-log-in"></span>Login</a></li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="container-fluid text-center">    
    <div class="row content">
      <div class="col-sm-2 sidenav">
        <p></p>
      </div>
      <div class="col-sm-8 text-left"> 
        <br>
        
        <div id="modalContainer" style="display:none;">
          <div id="durationModal">
            <p>Select your pushup session duration:</p>
            <select id="durationSelect">
              <option value="10">10 seconds</option>
              <option value="20">20 seconds</option>
              <option value="30">30 seconds</option>
              <option value="60" selected>60 seconds</option>
              <option value="120">120 seconds</option>
            </select>
            <button id="okButton">Ok</button>
          </div>
        </div>

        <canvas class="output_canvas_1" width="320px" height="180px" style="width:49%; height:49%"></canvas>
        <canvas class="output_canvas_2" id="output_canvas_2" width="320px" height="180px" style="display:none;"></canvas>
        <br><input type="checkbox" id="input_type"> Camera?&nbsp&nbsp&nbsp
        Video Position <select class="cam_pos" id="cam_pos"> 
          <option value="9" selected>9 o'clock</option>
          <option value="11">11</option>
          <option value="7">7</option>
        </select>

        <input type="file" id="input_file" accept="video/*"/><br> 
        <video class="input_file" width="220px" height="180px" controls></video>
        <video class="input_camera" autoplay="true" width="220px" height="180px"></video>

        <br>(P) of Correct Pose&nbsp&nbsp&nbsp<span id="UndisposedMem">Undisposed Mem: 0 MB</span>
        <input type="textarea" style="width:100%" id="poseResult" name="poseResult" readonly><br>
        <!--Adding my export button here-->
        <button id="exportButton">Export Data (Whole)</button>
        <button id="exportButtonFormatted">Export Data (Last Input Formatted)</button>
        <button id="submitJSON">Submit JSON to Database</button>
        <br>
        <div style="display:none">
        <br>Left Wrist (x)&nbsp<input type="textarea" style="width:20%" id="leftWrist" name="leftWrist" readonly>
        &nbsp&nbsp&nbspRight Wrist (x)&nbsp</label><input type="textarea" style="width:20%" id="rightWrist" name="rightWrist" readonly>
        </div>
        <br><button id="toggleSend" onclick="toggleSend()">Start Predict</button>
        Sampling Rate <input type="number" id="samplingRate" min="20" max="30" value="24">
        Predict By <select class="predict_by" id="predict_by"> 
          <option value="CNN" selected>CNN</option>
          <option value="angles">Angles</option>
        </select>
        <br><br>
        
        <canvas id="perfChart" style="max-width:100%; max-height:30%"></canvas><br>
        
        <!--Adding my export chart button here-->
        <button id="exportChartButton">Export Chart</button>
        <button id="exportBase64Button">Export Chart (In Base64 Encoding)</button>

      </div>
      <div class="col-sm-2 sidenav">
        <div class="well">
          <p></p>
        </div>
        <div class="well">
          <p></p>
        </div>
      </div>
    </div>
  </div>

  <footer class="container-fluid text-center">
    <p>Republic Polytechnic IGO Project</p>
  </footer>

  <p id="pose_results" style="display:none;"></p>
</body>

<script>
//**Setting variables as false first. 
let hasSpoken = false; 
let isBackStraightAlready = false;
let isArmStraightAlready = false;
var hasFormBeenCorrect = false;

// Disable the button so the program can only do it manually. 
document.getElementById("toggleSend").disabled = true;

//** POP up requesting for configurable period for pushup duration
window.onload = function(){
  document.getElementById('modalContainer').style.display = 'block';
}

document.getElementById('okButton').addEventListener('click', function() {
  var selectedDuration = document.getElementById('durationSelect').value;
  localStorage.setItem('selectedDuration', selectedDuration);
  document.getElementById('modalContainer').style.display = 'none';
});

  // By default, push_ups and 9 oc positions
  var exercise = exercises.find(exercise => exercise.type === "push_up" &&
    exercise.cam_pos === "9oc");
 
  var poseModel_1,  poseModel_2, oldPoseModel, flowModel, neg_emb_1, pos_emb_1, neg_emb_2, pos_emb_2;
  var frameCount = 0, exCount = 0, goodCount = 0, badCount = 0, max_angle = 0, min_angle = 150,
    perfChart = null, currPoseModel = "9", prevShoulderY = 0, currShoulderY = 0;
  // 150 is just an arbitarily large number
  var prevAPF = {angle:0, pose:"", flow:""};
  var last5PosePredict = [], flowClassifyResults = "";
  var cam_pos = document.getElementById('cam_pos');
  cam_pos.addEventListener('change', switchPoseModel);

  // load the set of -ive and +ive embeddings for comparison later
  // These are not used anymore
  /* (async function () {
    let response = await fetch("static/models/pushup-pose_I/negative_embedding.json");
    neg_emb_1 = await response.json();
    for(i = 0; i < neg_emb_1.length; i++) {
      neg_emb_1[i] = Float32Array.from(neg_emb_1[i]);
    }
    response = await fetch("static/models/pushup-pose_I/positive_embedding.json");
    pos_emb_1 = await response.json();
    for(i = 0; i < pos_emb_1.length; i++) {
      pos_emb_1[i] = Float32Array.from(pos_emb_1[i]);
    }
    response = await fetch("static/models/pushup-pose_II/negative_embedding.json");
    neg_emb_2 = await response.json();
    for(i = 0; i < neg_emb_2.length; i++) {
      neg_emb_2[i] = Float32Array.from(neg_emb_2[i]);
    }
    response = await fetch("static/models/pushup-pose_II/positive_embedding.json");
    pos_emb_2 = await response.json();
    for(i = 0; i < pos_emb_2.length; i++) {
      pos_emb_2[i] = Float32Array.from(pos_emb_2[i]);
    }
  })(); */

  (async function () {
    /* poseModel_1 = await tf.loadLayersModel("static/models/pushup-pose_I/model.json");
    poseModel_2 = await tf.loadLayersModel("static/models/pushup-pose_II/model.json"); */
    oldPoseModel = await tf.loadLayersModel("static/models/pushup-pose_9oc/model.json");
    oldPoseModel.summary();
    currPoseModel = "9";
    flowModel = await tf.loadGraphModel("static/models/pushup-flow/model.json");
  })();

  async function classifyPose_1(angle_shk, angle_hka) {
    let imagePoseOnly = document.getElementsByClassName('output_canvas_1')[0];

    /* let imageOrig = null;
    const inputType = document.querySelector('#input_type'); 
    const videoElementFile = document.getElementsByClassName('input_file')[0];
    const videoElementCamera = document.getElementsByClassName('input_camera')[0];
    
    if (inputType.checked)
      imageOrig =  videoElementCamera;
    else
      imageOrig = videoElementFile; */

    let t_angles = tf.tensor1d([angle_shk, angle_hka]).expandDims();
    let t_imagePoseOnly = tf.browser.fromPixels(imagePoseOnly)
      .resizeNearestNeighbor([180, 320]).toFloat().div(tf.scalar(255)).reverse(2).expandDims();

    // let t_imageOrig = tf.browser.fromPixels(imageOrig)
    //  .resizeNearestNeighbor([180, 320]).toFloat().div(tf.scalar(255)).expandDims().reverse(-1);
    // let t_imageOrig = tf.browser.fromPixels(imageOrig)
    //  .resizeNearestNeighbor([180, 320]).toFloat().div(tf.scalar(255)).reverse(2).expandDims();

    // let t_array = tf.concat([t_imageOrig, t_imagePoseOnly], 3);
    let poseResults_1 = [];
    // poseResults_1 = await poseModel_1.predict(t_array).data();
    // poseResults_1 = await oldPoseModel.predict(t_array).data();
    poseResults_1 = await oldPoseModel.predict([t_imagePoseOnly, t_angles]).data();
    return([poseResults_1]);

    /* let avgNegSim_1 = 0, avgPosSim_1 = 0;
    avgNegSim_1 = avgCosineSim(poseResults_1, neg_emb_1);
    avgPosSim_1 = avgCosineSim(poseResults_1, pos_emb_1);

    console.log ("AVE (Model  I) +/- " + avgPosSim_1 + " " + avgNegSim_1);

    return ([avgPosSim_1, avgNegSim_1]); */
  }

  async function classifyPose_2() {
    let imagePoseOnly = document.getElementsByClassName('output_canvas_1')[0];

    let imageOrig = null;
    const inputType = document.querySelector('#input_type'); 
    const videoElementFile = document.getElementsByClassName('input_file')[0];
    const videoElementCamera = document.getElementsByClassName('input_camera')[0];
    
    if (inputType.checked)
      imageOrig =  videoElementCamera;
    else
      imageOrig = videoElementFile;

    let t_imagePoseOnly = tf.browser.fromPixels(imagePoseOnly)
      .resizeNearestNeighbor([180, 320]).toFloat().div(tf.scalar(255)).expandDims();
    // let t_imageOrig = tf.browser.fromPixels(imageOrig)
    //  .resizeNearestNeighbor([180, 320]).toFloat().div(tf.scalar(255)).expandDims().reverse(-1);
    let t_imageOrig = tf.browser.fromPixels(imageOrig)
      .resizeNearestNeighbor([180, 320]).toFloat().div(tf.scalar(255)).reverse(2).expandDims();

    let t_array = tf.concat([t_imageOrig, t_imagePoseOnly], 3);
    let poseResults_2 = [];
    poseResults_2 = await poseModel_2.predict(t_array).data();
    // let poseResults = await oldPoseModel.predict(t_array).data();

    let avgNegSim_2 = 0, avgPosSim_2 = 0;
    avgNegSim_2 = avgCosineSim(poseResults_2, neg_emb_2);
    avgPosSim_2 = avgCosineSim(poseResults_2, pos_emb_2);

    console.log ("AVE (Model II) +/- " + avgPosSim_2 + " " + avgNegSim_2);

    return ([avgPosSim_2, avgNegSim_2]);
  }

  async function classifyFlow() {
    let imageFlowOnly = document.getElementsByClassName('output_canvas_2')[0];
    let t_imageFlowOnly = tf.browser.fromPixels(imageFlowOnly)
      .resizeNearestNeighbor([180, 320]).toFloat().div(tf.scalar(255)).expandDims();
    let flowResult = await flowModel.predict(t_imageFlowOnly).data();
    let max=-1, max_i, movtDir;

    flowResult.forEach((element, index) => { 
      if (max < element) {
        max = element;   
        max_i = index; 
      }
    });

    if (max_i == 0)
      movtDir = "Down";
    else if (max_i == 1)
      movtDir = "No Movement";
    else
      movtDir = "Up";

    return movtDir;
  }

  function toggleSend() {
    var toggleButton = document.getElementById("toggleSend");
    if (toggleButton.innerHTML == "Start Predict") {
      toggleButton.innerHTML = "Stop Predict";
    } else {
      toggleButton.innerHTML = "Start Predict";
    }
  }

  // load the correct model based on cam position
  function switchPoseModel () {
    if (this.value != currPoseModel) {
      let newModelToLoad = "static/models/pushup-pose_".concat(
        this.value).concat("oc/model.json");
      (async function () {
        oldPoseModel = await tf.loadLayersModel(newModelToLoad);
        // oldPoseModel.summary();
        currPoseModel = this.value;
      })();
      exercise = exercises.find(exercise => exercise.type === "push_up" &&
      exercise.cam_pos === this.value.concat("oc"));
    }
  }

  function cosineSim(A, B) {
    let dotProduct = 0, mA = 0, mB = 0;

    for (let i = 0; i < A.length; i++) {
        dotProduct += (A[i] * B[i]);
        mA += (A[i]*A[i]);
        mB += (B[i]*B[i]);
    }
    mA = Math.sqrt(mA);
    mB = Math.sqrt(mB);
    return (dotProduct)/((mA)*(mB));
  }

  function avgCosineSim(A, B) {
    let totalCosSim = 0;
    for (let i = 0; i < B.length; i++) {
      totalCosSim += cosineSim(A, B[i]);
    }
    return (totalCosSim/B.length);
  }
</script>

<script async src="https://docs.opencv.org/4.5.2/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
<script type="text/javascript">
  var cap, frame2, prvs, hsv0, hsv1, hsv2, hsvVec, frame2, flow, flowVec, next,
      mag, ang, rgb, OpenCvReady = false;

  function resetOpenCv(videoElement) {
      cap = new cv.VideoCapture(videoElement);
      // take first frame of the video
      frame1 = new cv.Mat(videoElement.height, videoElement.width, cv.CV_8UC4);
      cap.read(frame1);

      prvs = new cv.Mat();
      cv.cvtColor(frame1, prvs, cv.COLOR_RGBA2GRAY);
      frame1.delete();
      hsv = new cv.Mat();
      hsv0 = new cv.Mat(videoElement.height, videoElement.width, cv.CV_8UC1);
      hsv1 = new cv.Mat(videoElement.height, videoElement.width, cv.CV_8UC1, new cv.Scalar(255));
      hsv2 = new cv.Mat(videoElement.height, videoElement.width, cv.CV_8UC1);
      hsvVec = new cv.MatVector();
      hsvVec.push_back(hsv0); hsvVec.push_back(hsv1); hsvVec.push_back(hsv2);

      frame2 = new cv.Mat(videoElement.height, videoElement.width, cv.CV_8UC4);
      next = new cv.Mat(videoElement.height, videoElement.width, cv.CV_8UC1);
      flow = new cv.Mat(videoElement.height, videoElement.width, cv.CV_32FC2);
      flowVec = new cv.MatVector();
      mag = new cv.Mat(videoElement.height, videoElement.width, cv.CV_32FC1);
      ang = new cv.Mat(videoElement.height, videoElement.width, cv.CV_32FC1);
      rgb = new cv.Mat(videoElement.height, videoElement.width, cv.CV_8UC3);

      OpenCvReady = true;
  }
  function onOpenCvReady() {
    cv['onRuntimeInitialized'] = () => {
      let videoElementForDOF = document.getElementsByClassName('input_file')[0];
      resetOpenCv(videoElementForDOF);
    }
  }
  function drawFlow() {
    try {
        let begin = performance.now();
        if (OpenCvReady) {
        cap.read(frame2);
        cv.cvtColor(frame2, next, cv.COLOR_RGBA2GRAY);
        cv.calcOpticalFlowFarneback(prvs, next, flow, 0.5, 3, 15, 3, 5, 1.2, 0);
        cv.split(flow, flowVec);
        let u = flowVec.get(0);
        let v = flowVec.get(1);
        cv.cartToPolar(u, v, mag, ang);
        u.delete(); v.delete();
        ang.convertTo(hsv0, cv.CV_8UC1, 180/Math.PI/2);
        cv.normalize(mag, hsv2, 0, 255, cv.NORM_MINMAX, cv.CV_8UC1);
        cv.merge(hsvVec, hsv);
        cv.cvtColor(hsv, rgb, cv.COLOR_HSV2RGB);
        cv.imshow('output_canvas_2', rgb);
        next.copyTo(prvs);
        }

        // schedule the next one.
        // let delay = 1000/parseFloat(document.getElementById('samplingRate').value) - (performance.now() - begin);
        // setTimeout(drawFlow, delay);
    } catch (err) {
        console.log(err);
    }
  }
  // setTimeout is to schedule the next function call to draw the flow
  // commented out to call drawFlow everytime when onResults() is invoked
  // i.e. draw in realtime
  // setTimeout(drawFlow, 0);
</script>

<script type="module">
  const inputType = document.querySelector('#input_type');
  const videoElementFile = document.getElementsByClassName('input_file')[0];
  const videoElementCamera = document.getElementsByClassName('input_camera')[0];
  const canvasElement = document.getElementsByClassName('output_canvas_1')[0];
  // For mirror image, uncomment the following
  // canvasElement.style.transform = "scale(-1, 1)";
  const canvasCtx = canvasElement.getContext('2d');
  var lastSent = performance.now();

  // This is to calculate angles spread horizontally, e.g. Shoulder-Hip-Knee
  function calculateAngle_1 (a, b, c) {
    let arctan_1 = 0, arctan_2 = 0, angle_1 = 0, angle_2 = 0,
      angle_between_1_2 = 0;

    arctan_1 = Math.atan2(a[1] - b[1], a[0] - b[0]);
    arctan_2 = Math.atan2(c[1] - b[1], c[0] - b[0]);
    angle_1 = arctan_1 * 180/Math.PI;
    angle_2 = arctan_2 * 180/Math.PI;

    // For easy tracking, convert all to +ive angles first
    if (angle_1 < 0)
      angle_1 = 360 - Math.abs(angle_1);
    if (angle_2 < 0)
      angle_2 = 360 - Math.abs(angle_2);

    if (a[1] >= b[1])
      angle_between_1_2 = angle_2 - angle_1;
    if (a[1] < b[1])
      angle_between_1_2 = angle_2 + (360 - angle_1);
    
    return angle_between_1_2;
  }

// This is to calculate angles spread vertically, e.g. Shoulder-Elbow-Wrist
function calculateAngle_2 (a, b, c, view = "Right") {
  let arctan_1 = 0, arctan_2 = 0, angle_1 = 0, angle_2 = 0,
    angle_between_1_2 = 0;

  arctan_1 = Math.atan2(a[1] - b[1], a[0] - b[0]);
  arctan_2 = Math.atan2(c[1] - b[1], c[0] - b[0]);
  angle_1 = arctan_1 * 180/Math.PI;
  angle_2 = arctan_2 * 180/Math.PI;

  // For easy tracking, convert all to +ive angles first
  if (angle_1 < 0)
    angle_1 = 360 - Math.abs(angle_1);
  if (angle_2 < 0)
    angle_2 = 360 - Math.abs(angle_2);

  if (view == 'Left')
    angle_between_1_2 = angle_2 - angle_1;
  else if (view == 'Right') {
    if (a[1] >= b[1])
      angle_between_1_2 = 360 - (angle_2 - angle_1);
    if (a[1] < b[1])
      angle_between_1_2 = angle_1 - angle_2;
  }

  return angle_between_1_2;
 }
  /* function calculateAngle (a, b, c, reverse = true) {
    let A = Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2),
      B = Math.pow(b[0] - c[0], 2) + Math.pow(b[1] - c[1], 2),
      C = Math.pow(c[0] - a[0], 2) + Math.pow(c[1] - a[1], 2),
      radians = Math.acos( (A + B - C) / Math.sqrt(4* A * B) ),
      angle = Math.abs(radians * 180/Math.PI);
      if (b[1] > a[1] && b[1] > c[1])
        return 360 - Math.round(angle);
      else
        return Math.round(angle);
  } */

  function onResults(results) {
    frameCount++;
    console.log ("Frame %f", frameCount);

    canvasCtx.save();
    /* canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    canvasCtx.fillStyle = "black";
    canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height); */
    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
    
    // The following three draw functions are replaced with customised logic
    /* canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
    drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,
                   {color: '#00FF00', lineWidth: 1});
    drawLandmarks(canvasCtx, results.poseLandmarks,
                  {color: '#FF0000', lineWidth: 0, radius: 1});
     */
    if (typeof results.poseLandmarks == "undefined") {
      canvasCtx.fillStyle = "red";
      canvasCtx.font = "16px Comic Sans";
      canvasCtx.fillText("Oops! Please refresh page!", 5, 50);
      return; // do nothing since no human form is present
    }

    drawFlow(); // Draw dense optical flow image

    let idx_to_coordinates = [];

    // Scale Z values to between 0 and 1
    let min_z = 1, max_z = 0;
    for (let i = 0; i < results.poseLandmarks.length; i++) {
      if (results.poseLandmarks[i]['z'] <= min_z) {
        min_z = results.poseLandmarks[i]['z'];
      }
    }
    min_z = Math.abs(min_z);
    for (let i = 0; i < results.poseLandmarks.length; i++) {
      results.poseLandmarks[i]['z'] = results.poseLandmarks[i]['z'] + min_z;
    }
    for (let i = 0; i < results.poseLandmarks.length; i++) {
      if (results.poseLandmarks[i]['z'] > max_z)
        max_z = results.poseLandmarks[i]['z'];     
    }
    for (let i = 0; i < results.poseLandmarks.length; i++) {
     results.poseLandmarks[i]['z'] = results.poseLandmarks[i]['z'] / max_z;     
    }
    // End of scale Z to between 0 and 1

    // convert X, Y landmarks to pixel position
    let x_px, y_px;
    for (let i = 0; i < results.poseLandmarks.length; i++) {
      x_px = Math.min(Math.floor(results.poseLandmarks[i]['x'] * canvasElement.width), 
        canvasElement.width - 1);
      y_px = Math.min(Math.floor(results.poseLandmarks[i]['y'] * canvasElement.height),
        canvasElement.height- 1);
      idx_to_coordinates.push({"x": x_px,"y": y_px, "z": results.poseLandmarks[i]['z']});
    }
    // End of convert X, Y landmarks to pixel position

    // Determine if subject is facing right or left
    //**Add elbow and wrist posepoints.
    let pose_of_interests_right_view = [12, 14, 16, 24, 26, 28],
      pose_of_interests_left_view = [11, 13, 15, 23, 25, 27];
    let pose_of_interests = [], pose_view = '';
    if (idx_to_coordinates[0]['x'] > idx_to_coordinates[11]['x'] ||
      idx_to_coordinates[0]['x'] > idx_to_coordinates[12]['x']) {
        pose_of_interests = pose_of_interests_right_view;
        pose_view = 'Right';
    } else if (idx_to_coordinates[0]['x'] < idx_to_coordinates[11]['x'] ||
      idx_to_coordinates[0]['x'] < idx_to_coordinates[12]['x']) {
        pose_of_interests = pose_of_interests_left_view;
        pose_view = 'Left';
    }

    // Draw the connections
    let start_idx, end_idx, pt_1_x, pt_1_y, pt_2_x, pt_2_y, z_1, z_2, thickness;

    for (let i = 0; i < POSE_CONNECTIONS.length; i++) {
      start_idx = POSE_CONNECTIONS[i][0];
      end_idx = POSE_CONNECTIONS[i][1];

      if (pose_of_interests.includes(start_idx) && 
        pose_of_interests.includes(end_idx)) {
        pt_1_x = idx_to_coordinates[start_idx]['x'];
        pt_1_y = idx_to_coordinates[start_idx]['y'];
        pt_2_x = idx_to_coordinates[end_idx]['x'];
        pt_2_y = idx_to_coordinates[end_idx]['y'];
        z_1 =  idx_to_coordinates[start_idx]['z'];
        z_2 =  idx_to_coordinates[end_idx]['z'];

        if (z_1 < 0.5 || z_2 < 0.5)
          thickness = 4;
        else
          thickness = 5;

        canvasCtx.beginPath();
        canvasCtx.lineWidth = thickness;
        canvasCtx.moveTo(pt_1_x, pt_1_y);
        canvasCtx.lineTo(pt_2_x, pt_2_y);
        
        if (start_idx <= 10)
          canvasCtx.strokeStyle = 'rgb(0,255,0)';
        else if (start_idx > 10 && start_idx < 23)
          canvasCtx.strokeStyle = 'rgb(0,255,0)';
        else if (start_idx > 23)
          canvasCtx.strokeStyle = 'rgb(0,255,0)';
        canvasCtx.stroke();
      }
    } // End draw connections

    // Draw the pose points
    let radius;
    for (let i = 0; i < idx_to_coordinates.length; i++) {
      radius = Math.round(idx_to_coordinates[i]['z'] * 2);
      if (radius <= 1)
        radius = 2;
      canvasCtx.beginPath();
      canvasCtx.arc(idx_to_coordinates[i]['x'], idx_to_coordinates[i]['y'], 
        radius, 0, Math. PI * 2);
      if (pose_of_interests.includes(i)) {
        if (i <= 10) {
          canvasCtx.fillStyle = 'rgb(255,0,0)';
          canvasCtx.strokeStyle = 'rgb(255,0,0)';
        } else if (i > 10 && i < 23) {
          canvasCtx.fillStyle = 'rgb(255,0,0)';
          canvasCtx.strokeStyle = 'rgb(255,0,0)';
        } else if (i > 23) {
          canvasCtx.fillStyle = 'rgb(255,0,0)';
          canvasCtx.strokeStyle = 'rgb(255,0,0)';
        }
        canvasCtx.fill();
        canvasCtx.stroke();
        
      }
    }

    // for demo out purpose, just print the left and right wrists
    var left, right = "";
    right = JSON.stringify(results.poseLandmarks[16]['x'].toPrecision(2)) + ' (' +
      JSON.stringify(results.poseLandmarks[16]['visibility'].toPrecision(2)) + ')';
    right = right.replace(/\"/g,"");
    document.getElementById("rightWrist").value = right;
    left = JSON.stringify(results.poseLandmarks[15]['x'].toPrecision(2)) + ' (' +
      JSON.stringify(results.poseLandmarks[15]['visibility'].toPrecision(2)) + ')';
    left = left.replace(/\"/g,"");
    document.getElementById("leftWrist").value = left;
    document.getElementById("pose_results").innerHTML = JSON.stringify(results.poseLandmarks);

    let shoulder_pose_idx = 99, elbow_pose_idx = 99, wrist_pose_idx = 99, hip_pose_idx = 99,
      knee_pose_idx = 99, ankle_pose_idx = 99;
    if (pose_view == "Left") {
      shoulder_pose_idx = 11;
      elbow_pose_idx = 13;
      wrist_pose_idx = 15;
      hip_pose_idx = 23;
      knee_pose_idx = 25;
      ankle_pose_idx = 27;
    } else if (pose_view = "Right") {
      shoulder_pose_idx = 12;
      elbow_pose_idx = 14;
      wrist_pose_idx = 16;
      hip_pose_idx = 24;
      knee_pose_idx = 26;
      ankle_pose_idx = 28;
    }

    let shoulder=[], elbow=[], wrist=[], angle = 0;
    shoulder = [idx_to_coordinates[shoulder_pose_idx]['x'], canvasElement.height - idx_to_coordinates[shoulder_pose_idx]['y']];
    elbow = [idx_to_coordinates[elbow_pose_idx]['x'], canvasElement.height - idx_to_coordinates[elbow_pose_idx]['y']];
    wrist = [idx_to_coordinates[wrist_pose_idx]['x'], canvasElement.height - idx_to_coordinates[wrist_pose_idx]['y']];
    if (pose_view == "Left")
      angle = calculateAngle_2(shoulder, elbow, wrist, "Left");
    else
      angle = calculateAngle_2(shoulder, elbow, wrist);

    // log the height or prev and curr sholder height
    if (prevShoulderY = 0)// start of a new sequence
      prevShoulderY = shoulder[1];
    else
      prevShoulderY = currShoulderY;
    currShoulderY = shoulder[1];

    // angle of shoulder, hip and knee, this a temp method of judging push-up
    let hip = [], knee = [], angle_shk = 0;
    hip = [idx_to_coordinates[hip_pose_idx]['x'], canvasElement.height - idx_to_coordinates[hip_pose_idx]['y']];
    knee = [idx_to_coordinates[knee_pose_idx]['x'], canvasElement.height - idx_to_coordinates[knee_pose_idx]['y']];
    if (pose_view == "Left") {
      angle_shk = calculateAngle_1(knee, hip, shoulder);
    } else {
      angle_shk = calculateAngle_1(shoulder, hip, knee);
    }

    let ankle = [], angle_hka = 0;
    ankle = [idx_to_coordinates[ankle_pose_idx]['x'], canvasElement.height - idx_to_coordinates[ankle_pose_idx]['y']];
    if (pose_view == "Left")
      angle_hka = calculateAngle_1(ankle, knee, hip);
    else
      angle_hka = calculateAngle_1(hip, knee, ankle);

  setTimeout(() => {
    //**User form checker
    if(!checkPosePointsInFrame(idx_to_coordinates,canvasElement.width, canvasElement.height)){
      speakText("Not in frame!");
      return;
    } else {  
      //Condition check for user's back straightness & arm**
      if(!isBackStraightAlready){
        //Back Straightness
        let shoulder_coordinates = idx_to_coordinates[shoulder_pose_idx]; 
        let hip_coordinates = idx_to_coordinates[hip_pose_idx]; 
        let backStraight = checkBackStraightness(shoulder_coordinates, hip_coordinates);
        //Arm Straightness
        let elbow_coordinates = idx_to_coordinates[elbow_pose_idx];
        let wrist_coordinates = idx_to_coordinates[wrist_pose_idx];
        let armStraight = checkArmStraightness(shoulder_coordinates, elbow_coordinates, wrist_coordinates);

        if(!backStraight){
          speakText('Back is still not straight!..,');
          return;
        }else if(!armStraight){
          speakText('Arm is still not straight!..,');
          return;
        }else{
          if(!hasSpoken){
            // Enable the button
            document.getElementById("toggleSend").disabled = false;
            speakText("3, 2, 1, Go!");
            hasSpoken = true;
          }
          isBackStraightAlready = true;

          //**Automatically start predicting once the user's form is correct. 
          if(!hasFormBeenCorrect){
            hasFormBeenCorrect = true;
            //**Set a buffer time to compensate for the spoken countdown timer
            setTimeout(function(){
            document.getElementById('toggleSend').click();
            },3000);
          }
        //** Countdown to stop the program after X amount of seconds set by the user.
        const videoElement = document.querySelector('.input_file');
        var countdownValue = localStorage.getItem('selectedDuration');
        var countdownInterval = setInterval(function() {
          //-2 to compensate for the 2 second delay 
          if (countdownValue <= -2) {
            clearInterval(countdownInterval);
            speakText("Stop!");
            document.getElementById('toggleSend').click();
            videoElement.pause();
          } else {
            countdownValue--;
          }
        }, 1000);
      }
    }  


    // Predict according to the sampling rate
    var timeInterval = 1000 / parseFloat(document.getElementById('samplingRate').value);
    if (document.getElementById('toggleSend').innerHTML == "Stop Predict") {
      if (performance.now() - lastSent >= timeInterval) {
        lastSent = performance.now();
        tf.tidy (() => {
          let pose1Predict = classifyPose_1(angle_shk, angle_hka);
          // let pose2Predict = classifyPose_2();
          let flowPredict = classifyFlow();

          /* Promise.all([pose1Predict, pose2Predict, flowPredict]).then((results) => {
            // more like a good execution and less like a bad execution
            let avgPosSim_1 = results[0][0], avgNegSim_1 = results[0][1], 
              avgPosSim_2 = results[1][0], avgNegSim_2 = results[1][1],
              outcome = ""; 
            
            flowClassifyResults = results[2];

            if (avgPosSim_1 > avgNegSim_1 && avgPosSim_1 > avgPosSim_2 ) 
              outcome = "Good";
            else if (avgPosSim_2 > avgNegSim_2 && avgPosSim_2 >  avgPosSim_1)
              outcome = "Bad";
            else
              outcome = "Indeterminate" */

          Promise.all([pose1Predict, flowPredict]).then((results) => {
            let goodProb = results[0][0][0], badProb = results[0][0][1], outcome = "";
            flowClassifyResults = results[1];

            // Seems there is some inconsistency in determing flow direction so
            // do a manual check to see if it helps
            if (currShoulderY > prevShoulderY)
              flowClassifyResults = "Up";
            else if (currShoulderY < prevShoulderY)
              flowClassifyResults = "Down";
            else
              flowClassifyResults = "No Movement";

            console.log ("Frame/Good/Bad/Dir %f / %f / %f  / %s ", frameCount, goodProb, badProb, flowClassifyResults);
            if (goodProb >= badProb) 
              outcome = "Good";
            else
              outcome = "Bad";

            // Overwrite the outcome using angles measure, an option provided to user
            // Keep the predicting code segment running to get feel of performance
            if (document.getElementById('predict_by').value == "angles") {
              if (angle_shk > exercise.shk_angle_1)
                outcome = "Arched"; // Arched back 
              else if (angle_shk < exercise.shk_angle_2)
                outcome = "Cobra"; // Cobra pose
              else if (angle_shk >= exercise.shk_angle_2 &&
                angle_shk <= exercise.shk_angle_1)
                outcome = "Good";
              console.log("Shoulder/Hip/Knee: " + angle_shk + " Outcome " + outcome);
            }

            // record the last 5 predicts
            last5PosePredict.push({"outcome": outcome, "good_probability": goodProb,
              "bad_probability": badProb});

            if (last5PosePredict.length == 6)
                last5PosePredict.shift();
          });
        });

        document.getElementById("UndisposedMem").innerHTML = "Undisposed Mem:" + (tf.memory().numBytes/ (1024 * 1024)).toFixed(1) + " MB";
      }
    }
  }
},3000);

    let userAdvice = "";

    if (angle > 180 && (pose_view == "Left" && flowClassifyResults == "Down"))
      angle = 360 - angle // the obtuse (outer) angle is being returned, interested in the acute (inner) angle */

    // To prevent a max or min being stuck in a certain value
    if (max_angle == 999 && prevAPF.flow.includes("Up"))
      max_angle = 0; // reset to start tracking again.
    if (flowClassifyResults == "Down" && (prevAPF.flow.includes("Up") ||
      flowClassifyResults == "No Movement"))
      min_angle = 150; // reset to start tracking again.

    if (angle < min_angle)
      min_angle = angle
    if (angle > max_angle)
      max_angle = angle

    if (angle <= exercise.down_angle && flowClassifyResults == "Down") {
      prevAPF.angle = angle;
      prevAPF.pose = "N.A.";
      prevAPF.flow = flowClassifyResults + " Arms fully bent";
    } else if (angle > exercise.down_angle && (flowClassifyResults == "Down" || 
        flowClassifyResults == "No Movement")) {
      if (max_angle <= exercise.up_angle) { // Not fully straighten
        exCount++;
        badCount++;
        // max_angle = 999; // to prevent duplicate triggerring
        userAdvice = "Arms not straight";
        updatePerfChart (false, userAdvice);
        perfChart.update();
      }
      max_angle = 999 // to prevent duplicate trigger and to indicate the check has been made
      prevAPF.angle = angle;
      prevAPF.pose = "N.A.";
      prevAPF.flow = flowClassifyResults + " Arms not fully bent";
    } else if (angle > exercise.down_angle && (flowClassifyResults == "Up" ||
        flowClassifyResults == "No Movement")) {
      if (min_angle < 150 && angle >= exercise.up_angle) { // changed 06-Jan-22
        exCount++;
        // console.log("Last 5 predicts " + JSON.stringify(last5PosePredict));
        let numValidPose = 0;
        for (let i = 0; i < last5PosePredict.length; i++) {
            if(last5PosePredict[i].outcome == "Good") {
              numValidPose++;
            }
        }
        console.log("Num of valids in last 5 " + numValidPose);
        if (numValidPose >= 3 && min_angle <= exercise.down_angle) {
          goodCount++;
          updatePerfChart (true, "Good");
          perfChart.update();
        } else {
          badCount++;
          if (numValidPose < 3) {
            userAdvice = userAdvice + " Poor posture";
          }
          if (min_angle > exercise.down_angle)
            userAdvice = userAdvice + " Arms not fully bent";
          updatePerfChart (false, userAdvice.trim());
          perfChart.update();
        }
        min_angle = 150; // reset to prevent duplicate triggerring
        prevAPF.angle = angle;
        prevAPF.pose = "";
        prevAPF.flow = flowClassifyResults + " Arms fully straigthened";
      }
    } else if (angle < exercise.up_angle && (flowClassifyResults == "Up" || // changed 06-Jan-22
      flowClassifyResults == "No Movement")) {
        prevAPF.angle = angle;
        prevAPF.pose = "";
        prevAPF.flow = flowClassifyResults + " Arms not straight";
    }
    canvasCtx.restore();
    canvasCtx.fillStyle = "white";
    canvasCtx.font = "10px Comic Sans";

    if (last5PosePredict.length == 0) {
      const dtNow = new Date();
      console.log(`CSV,${dtNow.toISOString()},${frameCount},${Math.round(angle_shk)},` +
        `${Math.round(angle_hka)},${Math.round(angle)},0`);
    } else {
      const dtNow = new Date();
      console.log(`CSV,${dtNow.toISOString()},${frameCount},${Math.round(angle_shk)},` +
        `${Math.round(angle_hka)},${Math.round(angle)},` +
        `${last5PosePredict[last5PosePredict.length - 1].good_probability}`);
    }
    console.log("Total: " + exCount + ", Good: " + goodCount + ", Bad: " + badCount +
      ", SHK: " + Math.round(angle_shk) + ", HKA: " + Math.round(angle_hka) +
      ", SEW: " + Math.round(angle) + ", Max: " + Math.round(max_angle) +
      ", Min: " + Math.round(min_angle) +  " / " + userAdvice);

    canvasCtx.fillText("Total: " + exCount + ", Good: " + goodCount + ", Bad: " + badCount +
      ", SHK: " + Math.round(angle_shk) + ", HKA: " + Math.round(angle_hka) +
      ", SEW: " + Math.round(angle) + ", Max " + + Math.round(max_angle) +
      ", Min " + Math.round(min_angle),5, 15);
    canvasCtx.fillText ("User Advice: " + userAdvice, 5, 25);

    document.getElementById("poseResult").value = "Total: " + exCount + ", Good: " +
      goodCount + ", Bad: " + badCount + ", SHK: " + Math.round(angle_shk) +
      ", HKA: " + Math.round(angle_hka) +", SEW " + Math.round(angle) + ", Max: " + 
      Math.round(max_angle) + ", Min, " + Math.round(min_angle) +" / " + userAdvice;
  }

//Hail mary data export

// Get the poseResult element and the export button
const poseResultElement = document.getElementById("poseResult");
const exportButton = document.getElementById("exportButton");

let data = []; // keep this outside of the function

function exportDataToJSONFile() {
    let poseResultValue = poseResultElement.value.split(', ');

    // Extract each parameter from the string
    let total = parseInt(poseResultValue[0].split(': ')[1]);
    let good = parseInt(poseResultValue[1].split(': ')[1]);
    let bad = parseInt(poseResultValue[2].split(': ')[1]);
    let shk = parseInt(poseResultValue[3].split(': ')[1]);
    let hka = parseInt(poseResultValue[4].split(': ')[1]);
    let sew = parseInt(poseResultValue[5].split(' ')[1]); // Assuming "SEW 152" follows after ", "
    let max = parseInt(poseResultValue[6].split(': ')[1]);
    let min = parseInt(poseResultValue[7].split(': ')[1]); // Assuming "Min: 77" follows after ", "
    let advice = poseResultValue[8] ? poseResultValue[8].split(' / ')[1] : ""; // If exists, split by ' / '

    const instance = {
        Total: total,
        Good: good,
        Bad: bad,
        SHK: shk,
        HKA: hka,
        SEW: sew,
        Max: max,
        Min: min,
        Advice: advice,
        exercise: "Sit Ups",
        Timestamp: new Date().toISOString()
    };

    data.push(instance); // Push each instance into the data array
}

function downloadData() {
    // Convert data to JSON string
    const jsonData = JSON.stringify(data, null, 2);

    // Create a Blob object with the data
    const blob = new Blob([jsonData], { type: "application/json" });

    // Create a download link
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "poseResult.JSON";
    link.click();
}

// Call exportDataToJSONFile every 2000 milliseconds
setInterval(exportDataToJSONFile, 2000);

// Add an event listener that calls downloadData when the exportButton is clicked
exportButton.addEventListener("click", downloadData);

// Get the new button
const exportButtonFormatted = document.getElementById("exportButtonFormatted");

function exportLastDataToJSONFile() {
    let poseResultValue = poseResultElement.value.split(', ');

    // Extract each parameter from the string
    let total = parseInt(poseResultValue[0].split(': ')[1]);
    let good = parseInt(poseResultValue[1].split(': ')[1]);
    let bad = parseInt(poseResultValue[2].split(': ')[1]);
    let shk = parseInt(poseResultValue[3].split(': ')[1]);
    let hka = parseInt(poseResultValue[4].split(': ')[1]);
    let sew = parseInt(poseResultValue[5].split(' ')[1]); // Assuming "SEW 152" follows after ", "
    let max = parseInt(poseResultValue[6].split(': ')[1]);
    let min = parseInt(poseResultValue[7].split(': ')[1]); // Assuming "Min: 77" follows after ", "
    let advice = poseResultValue[8] ? poseResultValue[8].split(' / ')[1] : ""; // If exists, split by ' / '

    var canvas = document.getElementById('perfChart');  // Select the canvas with your chart
    var chartBase64 = canvas.toDataURL('image/png');   // Get chart as a base64 string

    // Remove the data URI scheme from the base64 string
    chartBase64 = chartBase64.replace('data:image/png;base64,', '');
    var chartBlob = base64ToBlob(chartBase64, 'image/png');

    const instance = {
        badcount: bad,
        chartBase64: chartBase64,
        date: new Date().toISOString(),
        excount: total,
        exercise: "Sit Ups",
        goodcount: good
    };

    // Create a new array and push the last instance into it
    let lastData = [];
    lastData.push(instance);

    // Convert lastData to JSON string
    const jsonData = JSON.stringify(lastData, null, 2);

    // Create a Blob object with the lastData
    const blob = new Blob([jsonData], { type: "application/json" });

    // Create a download link
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "LastPoseResult.JSON";
    link.click();
}

// Add an event listener that calls exportLastDataToJSONFile when the exportButtonFormatted is clicked
exportButtonFormatted.addEventListener("click", exportLastDataToJSONFile);

const submitButton = document.getElementById("submitJSON");

function submitButtonJSON() {
    let poseResultValue = poseResultElement.value.split(', ');

    // Extract each parameter from the string
    let total = parseInt(poseResultValue[0].split(': ')[1]);
    let good = parseInt(poseResultValue[1].split(': ')[1]);
    let bad = parseInt(poseResultValue[2].split(': ')[1]);
    let shk = parseInt(poseResultValue[3].split(': ')[1]);
    let hka = parseInt(poseResultValue[4].split(': ')[1]);
    let sew = parseInt(poseResultValue[5].split(' ')[1]); // Assuming "SEW 152" follows after ", "
    let max = parseInt(poseResultValue[6].split(': ')[1]);
    let min = parseInt(poseResultValue[7].split(': ')[1]); // Assuming "Min: 77" follows after ", "
    let advice = poseResultValue[8] ? poseResultValue[8].split(' / ')[1] : ""; // If exists, split by ' / '

    var canvas = document.getElementById('perfChart');  // Select the canvas with your chart
    var chartBase64 = canvas.toDataURL('image/png');   // Get chart as a base64 string

    // Remove the data URI scheme from the base64 string
    chartBase64 = chartBase64.replace('data:image/png;base64,', '');
    var chartBlob = base64ToBlob(chartBase64, 'image/png');

    const instance = {
        badcount: bad,
        chartBase64: chartBase64,
        date: new Date().toISOString(),
        excount: total,
        exercise: "Sit Ups",
        goodcount: good
    };

    // Create a new array and push the last instance into it
    let lastData = [];
    lastData.push(instance);

    // Convert lastData to JSON string
    const jsonData = JSON.stringify(lastData, null, 2);

    // Send the jsonData to the server using a POST request
    $.ajax({
        type: "POST",
        url: "/export",
        data: jsonData,
        contentType: "application/json",
        success: function(response) {
            alert("Data sent to server successfully");
        },
        error: function(error) {
            alert("There was an error sending the data to the server");
        }
    });
}

submitButton.addEventListener("click", submitButtonJSON);

function base64ToBlob(base64, mimeType) {
    var byteCharacters = atob(base64);
    var byteNumbers = new Array(byteCharacters.length);
    for (var i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    var byteArray = new Uint8Array(byteNumbers);
    return new Blob([byteArray], {type: mimeType});
}

//End of Hail mary data export

  function setUpMediaPose() {
    let pose =  new Pose({locateFile: (file) => {
      return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
    }});
    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });
    return pose;
  }
  var pose = setUpMediaPose();
  pose.onResults(onResults);

  async function timerCallback(videoElement, videoPose, isFile = true) {
    if ((videoElement.paused || videoElement.ended) && isFile)
      return;

    // send the frame to pose, wait and do it again recursively
    await videoPose.send({image: videoElement});
    setTimeout(() => {
      timerCallback(videoElement, videoPose);
    }, 0);
  }

  function playSelectedFile(event) {
    var file = this.files[0];
    videoElementFile.src = URL.createObjectURL(file);
  }
   
  var inputFile = document.querySelector('#input_file');
  inputFile.addEventListener('change', playSelectedFile, false);

  inputType.addEventListener('change', async () => {
    frameCount = 0, exCount = 0, goodCount = 0, badCount = 0, max_angle = 0, min_angle = 150
    last5PosePredict = [], flowClassifyResults = "", prevShoulderY = 0, currShoulderY = 0;
    if (typeof perfChart === "undefined" || perfChart != null)
        perfChart.destroy();
    perfChart = resetPerfChart(ctx);

    if (inputType.checked) { // Camera selected
      navigator.mediaDevices.enumerateDevices().then (
        function(devices) {
          let selectedCamId = 999;
          devices.forEach(function(device) {
            if (device.label.includes("GENERAL WEBCAM")) {
              console.log ("CAM, Selected General Web Cam " + device.deviceId);
              selectedCamId = device.deviceId;
            }
          })
        return selectedCamId;
        }
      ).then (
        function (selectedCamId) {
          console.log ("CAM, Select device " + selectedCamId);
          return navigator.mediaDevices.getUserMedia({video: true});
        }
      ).then (
        function (stream) {
          console.log ("CAM, Setting video input to selected device");
          videoElementCamera.srcObject = stream;
          let camPose = setUpMediaPose();
          camPose.onResults(onResults)
          timerCallback(videoElementCamera, camPose, false);
          // The Camera utility will override and ALWAYS use integrated camera
          /* const camera = new Camera(videoElementCamera, {
            onFrame: async () => {
              await camPose.send({image: videoElementCamera});
            },
            width: 320,
            height: 180
          }); */
          videoElementFile.pause();
          resetOpenCv(videoElementCamera);
          // camera.start();
        }
      ).catch (
        function(err) {
          console.log(err.name + ": " + err.message);
        }
      );
    } else { // File selected
      videoElementCamera.pause();
      resetOpenCv(videoElementFile);
      let videoPose = setUpMediaPose();
      videoPose.onResults(onResults)
      videoElementFile.addEventListener('play', () => {
        frameCount = 0, exCount = 0, goodCount = 0, badCount = 0,  max_angle = 0, min_angle = 150;
        last5PosePredict = [], flowClassifyResults = "", prevShoulderY = 0, currShoulderY = 0;
        if (typeof perfChart === "undefined" || perfChart != null)
          perfChart.destroy();
        perfChart = resetPerfChart(ctx);
        timerCallback(videoElementFile, videoPose);
      });
    }
  });

  // By default, choose file input

  videoElementFile.addEventListener('play', () => {
      frameCount = 0, exCount = 0, goodCount = 0, badCount = 0, max_angle = 0, min_angle = 150
      last5PosePredict = [], flowClassifyResults = "", prevShoulderY = 0, currShoulderY = 0;
      if (typeof perfChart === "undefined" || perfChart != null)
        perfChart.destroy();
      perfChart = resetPerfChart(ctx);
      timerCallback(videoElementFile, pose);
  });

  var ctx = document.getElementById('perfChart').getContext('2d');

  function resetPerfChart (ctxReset) {
    return new Chart(ctxReset, {
      type: 'bar',
      data: {
        labels: [],
        datasets: [{
          label: 'No of repetitions',
          data: [],
          backgroundColor: [],
          borderColor: [],
          borderWidth: 1
        }]
      },
      options: {
        scales: {
          x: {
            ticks: {
              autoskip: false,
              maxRotation: 90,
              minRotation:90
             }
          },
          y: {
            ticks: {
              display: false
             }
          }
        }
      }
    });
  }

  function updatePerfChart (valid, userAdvice) {
    if (valid) {
      perfChart.data.labels.push('Good');
      perfChart.data.datasets[0].data.push(1);
      perfChart.data.datasets[0].backgroundColor.push('lime');
      perfChart.data.datasets[0].borderColor.push('lime');
      // Play "good" audio
      const goodSpeech = new SpeechSynthesisUtterance(goodCount);
      window.speechSynthesis.cancel()
      window.speechSynthesis.speak(goodSpeech);
    } else {
      perfChart.data.labels.push(userAdvice);
      perfChart.data.datasets[0].data.push(1);
      perfChart.data.datasets[0].backgroundColor.push('pink');
      perfChart.data.datasets[0].borderColor.push('pink');
      // Play "bad" audio with the advice
      const badSpeech = new SpeechSynthesisUtterance(userAdvice);
      //But the requirements say "No Count" sooooo the issue of speaking out userAdvice
      //which is too long and can be cut-off can be ignored
      //at the end state the error
      window.speechSynthesis.cancel()
      window.speechSynthesis.speak(badSpeech);
    }
  } 

  //After updatePerfChart
  //Hail mary chart export

  const exportChartButton = document.getElementById("exportChartButton");
  exportChartButton.addEventListener("click", exportChart);
  //whenever you click the "Export Chart" button, 
  //the exportChart function will be called, 
  //and it will export the chart as an image.
  function exportChart() {
    var canvas = document.getElementById('perfChart');  // Select the canvas with your chart
    var dataUrl = canvas.toDataURL('image/png');   // Get chart as a data URL

    // Create a link element
    var link = document.createElement('a');
    link.download = 'chart.png';                   // Name of the downloaded file
    link.href = dataUrl;                           // Link to the image data

    // Append link to the body
    document.body.appendChild(link);

    // Simulate click to start download
    link.click();

    // Remove link from the body
    document.body.removeChild(link);
    
  }

  const exportBase64Button = document.getElementById("exportBase64Button");
  exportBase64Button.addEventListener("click", exportChartBase64);
  // whenever you click the "Export Chart Base64" button, 
  // the exportChartBase64 function will be called, 
  // and it will export the chart as a base64 string.
  function exportChartBase64() {
      var canvas = document.getElementById('perfChart');  // Select the canvas with your chart
      var dataUrl = canvas.toDataURL('image/png');   // Get chart as a data URL

      // Create a Blob with the base64 string
      var blob = new Blob([dataUrl], {type: "text/plain;charset=utf-8"});

      // Create a link element
      var link = document.createElement('a');
      link.download = 'chart_base64.txt';           // Name of the downloaded file
      link.href = window.URL.createObjectURL(blob); // Link to the blob

      // Append link to the body
      document.body.appendChild(link);

      // Simulate click to start download
      link.click();

      // Remove link from the body
      document.body.removeChild(link);
  }

  function speakText(text){
  const synth = window.speechSynthesis;
  const utterance = new SpeechSynthesisUtterance(text);
  synth.speak(utterance);
  }

  function checkPosePointsInFrame(points, width, height) {
  for (let i = 0; i < points.length; i++) {
    if (points[i]['x'] < 0 || points[i]['y'] < 0 || points[i]['x'] > width || points[i]['y'] > height) {
      return false;
    }
  }
  return true;
} 
function checkArmStraightness(shoulder_coordinates, elbow_coordinates, wrist_coordinates){
    const tolerance = 20;

    let shoulder_elbow_diff = Math.abs(shoulder_coordinates.x - elbow_coordinates.x);
    let elbow_wrist_diff = Math.abs(elbow_coordinates.x - wrist_coordinates.x);

    if(shoulder_elbow_diff <= tolerance && elbow_wrist_diff <= tolerance){
      return true;
    } else {
      return false;
    }
}
function checkBackStraightness(shoulder_coordinates, hip_coordinates) {
    const tolerance = 20;  // Tolerance for vertical alignment. 
    let y_diff = Math.abs(shoulder_coordinates.y - hip_coordinates.y); 
    if (y_diff <= tolerance) {
        return true;  // Back is straight.
    } else {
        return false;  // Back is not straight.
    }
}

</script>
</html>
